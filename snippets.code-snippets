{
  "newtype": {
    "scope": "unison,u",
    "prefix": "#newtype",
    "body": [
      "type $1 = $1 ${2:Text}",
      "$1.unwrap = cases $1 v -> v",
      "$0"
    ],
    "description": "Create a newtype and a function to unwrap it"
  },
  "ability": {
    "scope": "unison,u",
    "prefix": "#ability",
    "body": [
      "ability $1 where",
      "\tfoo : Text ->{$1} Text",
      "",
      "$1.run : '{g, $1} a -> {g, ${2:IO, Exception}} a",
      "$1.run p =",
      "\tgo : '{g, $1} a -> {g, ${2:IO, Exception}} a",
      "\tgo p = handle !p with cases",
      "\t\t{foo input -> resume} ->",
      "\t\t\tresult = todo \"fill in the implementation\"",
      "\t\t\tgo '(resume result)",
      "\t\t{ k } -> k",
      "\tgo p",
      "$0"
    ],
    "description": "Stub a new ability and a corresponding handler"
  },
  "routes": {
    "scope": "unison,u",
    "prefix": "#routes",
    "body": [
      "$1.routes : '{Route, Log} ()",
      "$1.routes =",
      "\tuse Parser / s",
      "\tuse Route <|>",
      "\thelloWorld = do",
      "\t\tname = route GET (s \"hello\" / Parser.text)",
      "\t\tok.text (\"Hello, \" ++ name)",
      "\thelloWorld"
    ],
    "description": "Stub a routes function"
  },
  "deploy": {
    "scope": "unison,u",
    "prefix": "#deploy",
    "body": [
      "deploy.deploy : '{IO, Exception} URI",
      "deploy.deploy = Cloud.main do",
      "\tenvironment = !Environment.default",
      "\tdatabase = main.initializeStorage environment",
      "\tserviceName = ServiceName.create \"$1\"",
      "\tserviceHash = deployHttp environment (main database)",
      "\tServiceName.assign serviceName serviceHash",
      "",
      "deploy.root : Text",
      "deploy.root = \"\"",
      "",
      "main.initializeStorage : Environment ->{Exception, Cloud} Database",
      "main.initializeStorage env =",
      "\tdatabase = Database.create \"myDatabase\"",
      "\tDatabase.assign database env",
      "\tdatabase",
      "",
      "main.main :",
      "\tDatabase",
      "\t\t-> HttpRequest",
      "\t\t->{Exception, Storage, Remote, Random, Log} HttpResponse",
      "main.main db req =",
      "\tuse Route <|>",
      "\tRoute.run",
      "\t\t(todo \"put routes here\")",
      "\t\treq"
    ],
    "description": "Stub the spine of the app with a deploy and main function"
  },
  "crud": {
    "scope": "unison,u",
    "prefix": "#crud",
    "body": [
      "-- The data type we are operating on: $1",
      "type $1 = { id : $1.Id }",
      "type $1.Id = Id Text",
      "$1.Id.unwrap = cases Id v -> v",
      "",
      "ability $1CRUD where",
      "\tupsert : $1 ->{$1CRUD} ()",
      "\tget : $1.Id ->{$1CRUD} (Optional $1)",
      "\tdelete : $1.Id ->{$1CRUD} ()",
      "\tgetAll : '{$1CRUD} (List $1)",
      "",
      "$1CRUD.run : Database -> '{g, $1CRUD} a -> {g, Remote} a",
      "$1CRUD.run db p =",
      "\t${1/(.*)/${1:/camelcase}/}s : OrderedTable ($1.Id) $1",
      "\t${1/(.*)/${1:/camelcase}/}s = OrderedTable.named db \"${1/(.*)/${1:/camelcase}/}s\" Universal.ordering",
      "",
      "\tget$1' : $1.Id ->{g, Remote} (Optional $1)",
      "\tget$1' ${1/(.*)/${1:/camelcase}/}Id = OrderedTable.tryRead ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      
      "\tgetAll' : '{g, Remote} (List $1)",
      "\tgetAll' = do OrderedTable.toStream ${1/(.*)/${1:/camelcase}/}s |> Stream.map at2 |> Stream.toList",
      "",
      "\tupsert$1' : $1 ->{g, Remote} ()",
      "\tupsert$1' ${1/(.*)/${1:/camelcase}/} =",
      "\t\t${1/(.*)/${1:/camelcase}/}Id = $1.id ${1/(.*)/${1:/camelcase}/}",
      "\t\tOrderedTable.write ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id ${1/(.*)/${1:/camelcase}/}",
      "",
      "\tdelete$1' : $1.Id ->{g, Remote} ()",
      "\tdelete$1' ${1/(.*)/${1:/camelcase}/}Id =",
      "\t\tOrderedTable.delete ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      "\tgo : '{g, $1CRUD} a -> {g, Remote} a",
      "\tgo p = handle !p with cases",
      "\t\t{upsert ${1/(.*)/${1:/camelcase}/} -> resume} ->",
      "\t\t\tresult = upsert$1' ${1/(.*)/${1:/camelcase}/}",
      "\t\t\tgo '(resume result)",
      "\t\t{get ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = get$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{getAll _ -> resume} ->",
      "\t\t\tresult = getAll' ()",
      "\t\t\tgo '(resume result)",
      "\t\t{delete ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = delete$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{ k } -> k",
      "\tgo p"
    ],
    "description": "Stub a crud ability with a handler."
  },
  "json": {
    "scope": "unison,u",
    "prefix": "#json",
    "body": [
      "$1.fromJson : '{Decoder} $1",
      "$1.fromJson = do",
      "\tuse Decoder text",
      "\tuse object at!",
      "\tfoo = at! \"foo\" text",
      "\tbar = optionalAt! \"bar\" text",
      "\t$1 foo bar"
    ],
    "description": "Stub a decoder for a JSON object"
  },
  "crudRoutes": {
    "scope": "unison,u",
    "prefix": "#crudRoutes",
    "body": [
      "$1s.routes : '{Route, Log, Exception} ()",
      "$1s.routes =",
      "\tget${1/(.*)/${1:/pascalcase}/}s = do",
      "\t\t_ = Route.noCapture GET (Parser.s \"$1s\")",
      "\t\ttodo \"Get all $1s\"",
      "\t\tp [] [text \"render them as html\"] |> toText |> ok.html",
      "\tpost${1/(.*)/${1:/pascalcase}/}s = do",
      "\t\t_ = Route.noCapture POST (Parser.s \"$1s\")",
      "\t\tformData = getFormData()",
      "\t\ttodo \"Parse out form data, save, and return something\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tget${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route GET (Parser.s \"$1s\" / Parser.text)",
      "\t\ttodo \"Get a single $1 using the id\"",
      "\t\tp [] [text \"render it as html\"] |> toText |> ok.html",
      "\tpost${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route POST (Parser.s \"$1s\" / Parser.text)",
      "\t\tformData = getFormData()",
      "\t\ttodo \"Parse out form data, save, and return something\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tdelete${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route DELETE (Parser.s \"$1s\" / Parser.text)",
      "\t\ttodo \"Delete a single $1 using the id\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tget${1/(.*)/${1:/pascalcase}/}s <|> post${1/(.*)/${1:/pascalcase}/}s <|> get${1/(.*)/${1:/pascalcase}/} <|> post${1/(.*)/${1:/pascalcase}/} <|> delete${1/(.*)/${1:/pascalcase}/}",
    ]
  },
  "model": {
    "scope": "unison,u",
    "prefix": "#model",
    "body": [
      "-- The data type we are operating on: $1",
      "type $1 = { id : $1.Id }",
      "type $1.Id = Id Text",
      "$1.Id.unwrap = cases Id v -> v",
    ],
    "description": "Stub a model"
  },
  "crudAbility": {
    "scope": "unison,u",
    "prefix": "#crudAbility",
    "body": [
      "ability $1CRUD where",
      "\tupsert : $1 ->{$1CRUD} ()",
      "\tget : $1.Id ->{$1CRUD} (Optional $1)",
      "\tdelete : $1.Id ->{$1CRUD} ()",
      "\tgetAll : '{$1CRUD} (List $1)",
      "",
      "$1CRUD.run : Database -> '{g, $1CRUD} a -> {g, Remote} a",
      "$1CRUD.run db p =",
      "\t${1/(.*)/${1:/camelcase}/}s : OrderedTable ($1.Id) $1",
      "\t${1/(.*)/${1:/camelcase}/}s = OrderedTable.named db \"${1/(.*)/${1:/camelcase}/}s\" Universal.ordering",
      "",
      "\tget$1' : $1.Id ->{g, Remote} (Optional $1)",
      "\tget$1' ${1/(.*)/${1:/camelcase}/}Id = OrderedTable.tryRead ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      
      "\tgetAll' : '{g, Remote} (List $1)",
      "\tgetAll' = do OrderedTable.toStream ${1/(.*)/${1:/camelcase}/}s |> Stream.map at2 |> Stream.toList",
      "",
      "\tupsert$1' : $1 ->{g, Remote} ()",
      "\tupsert$1' ${1/(.*)/${1:/camelcase}/} =",
      "\t\t${1/(.*)/${1:/camelcase}/}Id = $1.id ${1/(.*)/${1:/camelcase}/}",
      "\t\tOrderedTable.write ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id ${1/(.*)/${1:/camelcase}/}",
      "",
      "\tdelete$1' : $1.Id ->{g, Remote} ()",
      "\tdelete$1' ${1/(.*)/${1:/camelcase}/}Id =",
      "\t\tOrderedTable.delete ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      "\tgo : '{g, $1CRUD} a -> {g, Remote} a",
      "\tgo p = handle !p with cases",
      "\t\t{upsert ${1/(.*)/${1:/camelcase}/} -> resume} ->",
      "\t\t\tresult = upsert$1' ${1/(.*)/${1:/camelcase}/}",
      "\t\t\tgo '(resume result)",
      "\t\t{get ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = get$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{getAll _ -> resume} ->",
      "\t\t\tresult = getAll' ()",
      "\t\t\tgo '(resume result)",
      "\t\t{delete ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = delete$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{ k } -> k",
      "\tgo p"
    ],
    "description": "Stub a crud ability with a handler."
  },
  "auth": {
    "scope": "unison,u",
    "prefix": "#auth",
    "body": [
      "ability auth.Auth where",
      "\tgetUserByEmail : Text ->{Auth} Optional User",
      "\tgetUserById : Text ->{Auth} Optional User",
      "\thashPassword : Text ->{Auth} Text",
      "\tupsertUser : User ->{Auth} ()",
      "\tisPasswordValid : User -> Text ->{Auth} Boolean",
      "\tcreateSession : User -> Instant ->{Auth} Session",
      "\tisTokenForActiveSession : Text -> Instant ->{Auth} Boolean",
      "\tgetActiveSessionByToken : Text -> Instant ->{Auth} Optional Session",
      "",
      "type auth.Auth.handleSignup.SignupFailure",
      "\t= InvalidPassword Text",
      "\t| UserAlreadyExists",
      "\t| InvalidEmail",
      "",
      "type auth.Auth.LoginFailure",
      "\t= UserNotFound",
      "\t| InvalidPassword",
      "",
      "type auth.Session",
      "\t= { userId : Text, token : Text, expiresAt : Instant }",
      "",
      "type auth.User",
      "\t= { id : Text, preferredName : Text, email : Text, hashedPassword : Text }",
      "",
      "auth.Auth.getSessionFromCookie :",
      "\tInstant ->{Route, Exception, Auth} Optional Session",
      "auth.Auth.getSessionFromCookie now' =",
      "\tuse Optional None",
      "\tcookie = getCookie \"lyft-session\"",
      "\tmatch cookie with",
      "\t\tNone       -> None",
      "\t\tSome token -> getActiveSessionByToken token now'",
      "",
      "auth.Auth.handleLogin :",
      "\tText -> Text -> Instant ->{Auth} Either LoginFailure Session",
      "auth.Auth.handleLogin email password now =",
      "\tuser = getUserByEmail email",
      "\tmatch user with",
      "\t\tOptional.None -> Left UserNotFound",
      "\t\tSome u        ->",
      "\t\t\tisValid = isPasswordValid u password",
      "\t\t\tif isValid then",
      "\t\t\t\tsession = createSession u now",
      "\t\t\t\tRight session",
      "\t\t\telse Left LoginFailure.InvalidPassword",
      "",
      "auth.Auth.handleSignup :",
      "\tText -> Text -> Text -> Instant ->{Auth, Random} Either SignupFailure Session",
      "auth.Auth.handleSignup preferredName email password now =",
      "\tuse Nat <",
      "\tuser = getUserByEmail email",
      "\tmatch user with",
      "\t\tSome _ -> Left UserAlreadyExists",
      "\t\tOptional.None ->",
      "\t\t\tif Boolean.not (Text.contains \"@\" email) then Left InvalidEmail",
      "\t\t\telse",
      "\t\t\t\tif Text.size password < 8 then",
      "\t\t\t\t\tLeft",
      "\t\t\t\t\t\t(SignupFailure.InvalidPassword",
      "\t\t\t\t\t\t\t\"password must be at least 8 characters long\")",
      "\t\t\t\telse",
      "\t\t\t\t\thashedPassword = hashPassword password",
      "\t\t\t\t\tnewUser =",
      "\t\t\t\t\t\tUser.User",
      "\t\t\t\t\t\t\t(Uuid.new() |> Uuid.toText) preferredName email hashedPassword",
      "\t\t\t\t\tupsertUser newUser",
      "\t\t\t\t\tsession = createSession newUser now",
      "\t\t\t\t\tRight session",
      "",
      "auth.Auth.middleware.requireLogin :",
      "\t'{g, Route, Auth, Log} () ->{g, Route, Exception, Auth, Remote, Log} ()",
      "auth.Auth.middleware.requireLogin route =",
      "\tuse Path /",
      "\tnow' = Remote.now()",
      "\tisLoggedIn = getSessionFromCookie now' |> isSome",
      "\tmatch isLoggedIn with",
      "\t\ttrue  -> route()",
      "\t\tfalse ->",
      "\t\t\tpath = request.path()",
      "\t\t\tsetStatus (Status 303 \"Login\")",
      "\t\t\theaders.add \"Location\" (baseUrl() / \"login\" |> Path.toText)",
      "",
      "auth.Auth.run : Database -> '{g, Auth} a ->{g, Exception, Remote, Random} a",
      "auth.Auth.run db p =",
      "\tuse Instant + >",
      "\tuse Optional None",
      "\tuse OrderedTable named tryRead write",
      "\tuse Text ==",
      "\tuse Universal ordering",
      "\tusers : OrderedTable Text User",
      "\tusers = named db \"users2\" ordering",
      "\tusersByEmail : OrderedTable Text User",
      "\tusersByEmail = named db \"usersByEmail2\" ordering",
      "\tupsertUser' : User ->{g, Remote} ()",
      "\tupsertUser' user =",
      "\t\tuserId = User.id user",
      "\t\twrite users userId user",
      "\t\temail = User.email user",
      "\t\twrite usersByEmail email user",
      "\tgetUserById' : Text ->{g, Remote} Optional User",
      "\tgetUserById' id = tryRead users id",
      "\tgetUserByEmail' : Text ->{g, Remote} Optional User",
      "\tgetUserByEmail' email = tryRead usersByEmail email",
      "\tsessions : OrderedTable Text Session",
      "\tsessions = named db \"sessions\" ordering",
      "\tupsertSession : Session ->{g, Remote} ()",
      "\tupsertSession session =",
      "\t\tsessionToken = Session.token session",
      "\t\twrite sessions sessionToken session",
      "\tgetSessionByToken' : Text ->{g, Remote} Optional Session",
      "\tgetSessionByToken' token = tryRead sessions token",
      "\tsaltAndHashPassword : Text -> Text",
      "\tsaltAndHashPassword password =",
      "\t\tuse Text ++",
      "\t\tsalt = \"09324whtgwihgnvwsikghnwoliksdjh\"",
      "\t\tcrypto.hash Sha3_256 (salt ++ password) |> Bytes.toHex",
      "\tgo : '{g, Auth} a ->{g, Exception, Remote, Random} a",
      "\tgo p =",
      "\t\thandle p()",
      "\t\twith cases",
      "\t\t\t{ upsertUser user -> resume } ->",
      "\t\t\t\tresult = upsertUser' user",
      "\t\t\t\tgo do resume result",
      "\t\t\t{ getUserById id -> resume } ->",
      "\t\t\t\tresult = getUserById' id",
      "\t\t\t\tgo do resume result",
      "\t\t\t{ getUserByEmail email -> resume } ->",
      "\t\t\t\tresult = getUserByEmail' email",
      "\t\t\t\tgo do resume result",
      "\t\t\t{ isTokenForActiveSession token now -> resume } ->",
      "\t\t\t\tresult = getSessionByToken' token",
      "\t\t\t\tmatch result with",
      "\t\t\t\t\tNone -> go do resume false",
      "\t\t\t\t\tSome session ->",
      "\t\t\t\t\t\tif expiresAt session > now then go do resume true",
      "\t\t\t\t\t\telse go do resume false",
      "\t\t\t{ getActiveSessionByToken token now -> resume } ->",
      "\t\t\t\tresult = getSessionByToken' token",
      "\t\t\t\tmatch result with",
      "\t\t\t\t\tNone -> go do resume None",
      "\t\t\t\t\tSome session ->",
      "\t\t\t\t\t\tif expiresAt session > now then go do resume (Some session)",
      "\t\t\t\t\t\telse go do resume None",
      "\t\t\t{ createSession user now -> resume } ->",
      "\t\t\t\tsession =",
      "\t\t\t\t\tSession (User.id user) (Uuid.new() |> Uuid.toText) (now + days +30)",
      "\t\t\t\t_ = upsertSession session",
      "\t\t\t\tgo do resume session",
      "\t\t\t{ isPasswordValid user password -> resume } ->",
      "\t\t\t\tif hashedPassword user == saltAndHashPassword password then",
      "\t\t\t\t\tgo do resume true",
      "\t\t\t\telse go do resume false",
      "\t\t\t{ hashPassword rawPassword -> resume } ->",
      "\t\t\t\thashed = saltAndHashPassword rawPassword",
      "\t\t\t\tgo do resume hashed",
      "\t\t\t{ k } -> k",
      "\tgo p",
      "",
      "auth.Auth.setSessionCookie : Session ->{Route} ()",
      "auth.Auth.setSessionCookie session =",
      "\tcookie' = cookie \"lyft-session\" (Session.token session)",
      "\tsetCookie cookie'",
      "",
      "auth.components.LoginForm : Optional LoginFailure -> '{Route} Html",
      "auth.components.LoginForm failure =",
      "\tdo",
      "\t\tuse Attribute label",
      "\t\tuse Path / toText",
      "\t\tuse tapegram_html_2_0_0 text",
      "\t\tuse tapegram_html_2_0_0.Attribute required",
      "\t\tuse up.Attribute name",
      "\t\tactionUrl = baseUrl() / \"login\" |> toText",
      "\t\ttapegram_html_2_0_0.form",
      "\t\t\t[Attribute.method \"post\", action actionUrl]",
      "\t\t\t[ match failure with",
      "\t\t\t\tOptional.None -> html.empty",
      "\t\t\t\t_ ->",
      "\t\t\t\t\twa_callout",
      "\t\t\t\t\t\t[variant \"danger\"]",
      "\t\t\t\t\t\t[ wa_icon",
      "\t\t\t\t\t\t\t[ Attribute.slot \"icon\"",
      "\t\t\t\t\t\t\t, name \"circle-exclamation\"",
      "\t\t\t\t\t\t\t, family \"regular\"",
      "\t\t\t\t\t\t\t]",
      "\t\t\t\t\t\t\t[]",
      "\t\t\t\t\t\t, text \"Check your email and password and try again!\"",
      "\t\t\t\t\t\t]",
      "\t\t\t\t, wa_input",
      "\t\t\t\t\t[ label \"email\"",
      "\t\t\t\t\t, type' \"email\"",
      "\t\t\t\t\t, name \"email\"",
      "\t\t\t\t\t, required true",
      "\t\t\t\t\t, placeholder \"you@example.com\"",
      "\t\t\t\t\t]",
      "\t\t\t\t\t[]",
      "\t\t\t\t, br []",
      "\t\t\t\t, wa_input",
      "\t\t\t\t\t[ label \"password\"",
      "\t\t\t\t\t, type' \"password\"",
      "\t\t\t\t\t, name \"password\"",
      "\t\t\t\t\t, required true",
      "\t\t\t\t\t, placeholder \"**********\"",
      "\t\t\t\t\t]",
      "\t\t\t\t\t[]",
      "\t\t\t\t, br []",
      "\t\t\t\t, wa_button",
      "\t\t\t\t\t[type' \"submit\", Attribute.style \"width: 100%;\"] [text \"login\"]",
      "\t\t\t\t, br []",
      "\t\t\t\t, a",
      "\t\t\t\t\t[href (baseUrl() / \"signup\" |> toText)]",
      "\t\t\t\t\t[text \"don't have an account? sign up here.\"]",
      "\t\t\t\t]",
      "",
      "auth.components.SignupForm : Optional SignupFailure -> '{Route} Html",
      "auth.components.SignupForm failure =",
      "\tdo",
      "\t\tuse Attribute label slot",
      "\t\tuse Path / toText",
      "\t\tuse tapegram_html_2_0_0 text",
      "\t\tuse tapegram_html_2_0_0.Attribute required",
      "\t\tuse up.Attribute name",
      "\t\tactionUrl = baseUrl() / \"signup\" |> toText",
      "\t\ttapegram_html_2_0_0.form",
      "\t\t\t[Attribute.method \"post\", action actionUrl]",
      "\t\t\t[ match failure with",
      "\t\t\t\tOptional.None -> html.empty",
      "\t\t\t\tSome InvalidEmail ->",
      "\t\t\t\t\twa_callout",
      "\t\t\t\t\t\t[variant \"danger\"]",
      "\t\t\t\t\t\t[ wa_icon",
      "\t\t\t\t\t\t\t[slot \"icon\", name \"circle-exclamation\", variant \"regular\"]",
      "\t\t\t\t\t\t\t[]",
      "\t\t\t\t\t\t, text \"please enter a valid email address.\"",
      "\t\t\t\t\t\t]",
      "\t\t\t\tSome (SignupFailure.InvalidPassword msg) ->",
      "\t\t\t\t\twa_callout",
      "\t\t\t\t\t\t[variant \"danger\"]",
      "\t\t\t\t\t\t[ wa_icon",
      "\t\t\t\t\t\t\t[slot \"icon\", name \"circle-exclamation\", variant \"regular\"]",
      "\t\t\t\t\t\t\t[]",
      "\t\t\t\t\t\t, text msg",
      "\t\t\t\t\t\t]",
      "\t\t\t\tSome UserAlreadyExists ->",
      "\t\t\t\t\twa_callout",
      "\t\t\t\t\t\t[variant \"danger\"]",
      "\t\t\t\t\t\t[ wa_icon",
      "\t\t\t\t\t\t\t[slot \"icon\", name \"circle-exclamation\", variant \"regular\"]",
      "\t\t\t\t\t\t\t[]",
      "\t\t\t\t\t\t, text \"a user with that email already exists.\"",
      "\t\t\t\t\t\t]",
      "\t\t\t\t, wa_input",
      "\t\t\t\t\t[ label \"preferred name\"",
      "\t\t\t\t\t, type' \"text\"",
      "\t\t\t\t\t, name \"preferredName\"",
      "\t\t\t\t\t, Attribute \"autocomplete\" \"nickname\"",
      "\t\t\t\t\t, required true",
      "\t\t\t\t\t, placeholder \"Dave\"",
      "\t\t\t\t\t]",
      "\t\t\t\t\t[]",
      "\t\t\t\t, br []",
      "\t\t\t\t, wa_input",
      "\t\t\t\t\t[ label \"email\"",
      "\t\t\t\t\t, type' \"email\"",
      "\t\t\t\t\t, name \"email\"",
      "\t\t\t\t\t, required true",
      "\t\t\t\t\t, placeholder \"you@example.com\"",
      "\t\t\t\t\t]",
      "\t\t\t\t\t[]",
      "\t\t\t\t, br []",
      "\t\t\t\t, wa_input",
      "\t\t\t\t\t[ label \"password\"",
      "\t\t\t\t\t, type' \"password\"",
      "\t\t\t\t\t, name \"password\"",
      "\t\t\t\t\t, required true",
      "\t\t\t\t\t, placeholder \"**********\"",
      "\t\t\t\t\t]",
      "\t\t\t\t\t[]",
      "\t\t\t\t, br []",
      "\t\t\t\t, wa_button",
      "\t\t\t\t\t[type' \"submit\", Attribute.style \"width: 100%;\"] [text \"signup\"]",
      "\t\t\t\t, br []",
      "\t\t\t\t, a",
      "\t\t\t\t\t[href (baseUrl() / \"login\" |> toText)]",
      "\t\t\t\t\t[text \"already have an account? log in here.\"]",
      "\t\t\t\t]",
      "",
      "auth.NoFailure : Optional a",
      "auth.NoFailure = Optional.None",
      "",
      "auth.routes : '{Route, Exception, Auth, Remote, Random, Log} ()",
      "auth.routes =",
      "\tuse Route <|>",
      "\tuse badRequest html",
      "\tuse tapegram_html_2_0_0 toText",
      "\tgetLogin = do",
      "\t\t_ = noCapture GET (Parser.s \"login\")",
      "\t\tpage [LoginForm NoFailure ()] () |> okHtml",
      "\tpostLogin = do",
      "\t\t_ = noCapture POST (Parser.s \"login\")",
      "\t\tformData = getFormData()",
      "\t\temail = getOnly! \"email\" formData",
      "\t\tpassword = getOnly! \"password\" formData",
      "\t\tsession = handleLogin email password Remote.now()",
      "\t\tmatch session with",
      "\t\t\tLeft failure -> page [LoginForm (Some failure) ()] () |> toText |> html",
      "\t\t\tRight s      ->",
      "\t\t\t\t_ = setSessionCookie s",
      "\t\t\t\tredirect baseUrl()",
      "\tgetSignup = do",
      "\t\t_ = noCapture GET (Parser.s \"signup\")",
      "\t\tpage [SignupForm NoFailure ()] () |> okHtml",
      "\tpostSignup = do",
      "\t\t_ = noCapture POST (Parser.s \"signup\")",
      "\t\tformData = getFormData()",
      "\t\tpreferredName = getOnly! \"preferredName\" formData",
      "\t\temail = getOnly! \"email\" formData",
      "\t\tpassword = getOnly! \"password\" formData",
      "\t\tnow = Remote.now()",
      "\t\tresult = handleSignup preferredName email password now",
      "\t\tmatch result with",
      "\t\t\tLeft failure  -> page [SignupForm (Some failure) ()] () |> toText |> html",
      "\t\t\tRight session ->",
      "\t\t\t\t_ = setSessionCookie session",
      "\t\t\t\tredirect baseUrl()",
      "\tgetLogin <|> postLogin <|> getSignup <|> postSignup"
    ],
    "description": "Stub an authentication ability, handler, routes, components, and model. Small dependencies on WebAwesome components and some standard Unison libraries like Routes."
  },
}

