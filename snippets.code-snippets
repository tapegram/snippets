{
	"newtype": {
		"scope": "unison,u",
		"prefix": "newtype",
		"body": [
			"type $1 = $1 ${2:Text}",
			"$1.unwrap = cases $1 v -> v",
			"$0"
		],
		"description": "Create a newtype and a function to unwrap it"
	},
	"ability": {
		"scope": "unison,u",
		"prefix": "ability",
		"body": [
			"ability $1 where",
			"\tfoo : Text ->{$1} Text",
			"",
			"$1.run : '{g, $1} a -> {g, ${2:IO, Exception}} a",
			"$1.run p =",
			"\tgo : '{g, $1} a -> {g, ${2:IO, Exception}} a",
			"\tgo p = handle !p with cases",
			"\t\t{foo input -> resume} ->",
			"\t\t\tresult = todo \"fill in the implementation\"",
			"\t\t\tgo '(resume result)",
			"\t\t{ k } -> k",
			"\tgo p",
			"$0"
		],
		"description": "Stub a new ability and a corresponding handler"
	},
	"routes": {
		"scope": "unison,u",
		"prefix": "routes",
		"body": [
			"$1.routes : '{Route, Log} ()",
			"$1.routes =",
			"\tuse Parser / s",
			"\tuse Route <|>",
			"\thelloWorld = do",
			"\t\tname = route GET (s \"hello\" / Parser.text)",
			"\t\tok.text (\"Hello, \" ++ name)",
			"\thelloWorld"
		],
		"description": "Stub a routes function"
	},
	"deploy": {
		"scope": "unison,u",
		"prefix": "deploy",
		"body": [
			"deploy.deploy : '{IO, Exception} URI",
			"deploy.deploy = Cloud.main do",
			"\tenvironment = !Environment.default",
			"\tdatabase = main.initializeStorage environment",
			"\tserviceName = ServiceName.create \"$1\"",
			"\tserviceHash = deployHttp environment (main database)",
			"\tServiceName.assign serviceName serviceHash",
			"",
			"deploy.root : Text",
			"deploy.root = \"\"",
			"",
			"main.initializeStorage : Environment ->{Exception, Cloud} Database",
			"main.initializeStorage env =",
			"\tdatabase = Database.create \"myDatabase\"",
			"\tDatabase.assign database env",
			"\tdatabase",
			"",
			"main.main :",
			"\tDatabase",
			"\t\t-> HttpRequest",
			"\t\t->{Exception, State, Remote, Random, Log} HttpResponse",
			"main.main db req =",
			"\tuse Route <|>",
			"\tRoute.run",
			"\t\t(todo \"put routes here\")",
			"\t\treq"
		],
		"description": "Stub the spine of the app with a deploy and main function"
	},
	"crud": {
		"scope": "unison,u",
		"prefix": "crud",
		"body": [
			"-- The data type we are operating on: $1",
			"type $1 = { id : $1Id }",
			"type $1Id = $1Id Text",
			"$1Id.unwrap = cases $1Id v -> v",
			"",
			"ability $1CRUD where",
				"\tupsert : $1 ->{$1CRUD} ()",
				"\tget : $1Id ->{$1CRUD} (Optional $1)",
				"\tdelete : $1Id ->{$1CRUD} ()",
			"",
			"$1CRUD.run : Database -> '{g, $1CRUD} a -> {g, Remote} a",
			"$1CRUD.run db p =",
				"\t${1/(.*)/${1:/camelcase}/}s : BTree ($1Id) $1",
				"\t${1/(.*)/${1:/camelcase}/}s = BTree.named db \"${1/(.*)/${1:/camelcase}/}s\" Universal.ordering",
			"",
				"\tget$1' : $1Id ->{g, Remote} (Optional $1)",
				"\tget$1' ${1/(.*)/${1:/camelcase}/}Id = BTree.tryRead ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
			"",
				"\tupsert$1' : $1 ->{g, Remote} ()",
				"\tupsert$1' ${1/(.*)/${1:/camelcase}/} =",
					"\t\t${1/(.*)/${1:/camelcase}/}Id = $1.id ${1/(.*)/${1:/camelcase}/}",
					"\t\tBTree.write ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id ${1/(.*)/${1:/camelcase}/}",
			"",
				"\tdelete$1' : $1Id ->{g, Remote} ()",
				"\tdelete$1' ${1/(.*)/${1:/camelcase}/}Id =",
					"\t\tBTree.delete ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
			"",
				"\tgo : '{g, $1CRUD} a -> {g, Remote} a",
				"\tgo p = handle !p with cases",
					"\t\t{upsert ${1/(.*)/${1:/camelcase}/} -> resume} ->",
						"\t\t\tresult = upsert$1' ${1/(.*)/${1:/camelcase}/}",
						"\t\t\tgo '(resume result)",
					"\t\t{get ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
						"\t\t\tresult = get$1' ${1/(.*)/${1:/camelcase}/}Id",
						"\t\t\tgo '(resume result)",
					"\t\t{delete ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
						"\t\t\tresult = delete$1' ${1/(.*)/${1:/camelcase}/}Id",
						"\t\t\tgo '(resume result)",
					"\t\t{ k } -> k",
				"\tgo p"
		],
		"description": "Stub a crud ability with a handler."
	},
	"json": {
		"scope": "unison,u",
		"prefix": "json",
		"body": [
			"$1.fromJson : '{Decoder} $1",
			"$1.fromJson = do",
  		"\tuse Decoder text",
  		"\tuse object at!",
  		"\tfoo = at! \"foo\" text",
  		"\tbar = optionalAt! \"bar\" text",
  		"\t$1 foo bar"
		],
		"description": "Stub a decoder for a JSON object"
	}
}
