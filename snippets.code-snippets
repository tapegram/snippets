{
  "newtype": {
    "scope": "unison,u",
    "prefix": "#newtype",
    "body": [
      "type $1 = $1 ${2:Text}",
      "$1.unwrap = cases $1 v -> v",
      "$0"
    ],
    "description": "Create a newtype and a function to unwrap it"
  },
  "ability": {
    "scope": "unison,u",
    "prefix": "#ability",
    "body": [
      "ability $1 where",
      "\tfoo : Text ->{$1} Text",
      "",
      "$1.run : '{g, $1} a -> {g, ${2:IO, Exception}} a",
      "$1.run p =",
      "\tgo : '{g, $1} a -> {g, ${2:IO, Exception}} a",
      "\tgo p = handle !p with cases",
      "\t\t{foo input -> resume} ->",
      "\t\t\tresult = todo \"fill in the implementation\"",
      "\t\t\tgo '(resume result)",
      "\t\t{ k } -> k",
      "\tgo p",
      "$0"
    ],
    "description": "Stub a new ability and a corresponding handler"
  },
  "routes": {
    "scope": "unison,u",
    "prefix": "#routes",
    "body": [
      "$1.routes : '{Route, Log} ()",
      "$1.routes =",
      "\tuse Parser / s",
      "\tuse Route <|>",
      "\thelloWorld = do",
      "\t\tname = route GET (s \"hello\" / Parser.text)",
      "\t\tok.text (\"Hello, \" ++ name)",
      "\thelloWorld"
    ],
    "description": "Stub a routes function"
  },
  "deploy": {
    "scope": "unison,u",
    "prefix": "#deploy",
    "body": [
      "deploy.deploy : '{IO, Exception} URI",
      "deploy.deploy = Cloud.main do",
      "\tenvironment = !Environment.default",
      "\tdatabase = main.initializeStorage environment",
      "\tserviceName = ServiceName.create \"$1\"",
      "\tserviceHash = deployHttp environment (main database)",
      "\tServiceName.assign serviceName serviceHash",
      "",
      "deploy.root : Text",
      "deploy.root = \"\"",
      "",
      "main.initializeStorage : Environment ->{Exception, Cloud} Database",
      "main.initializeStorage env =",
      "\tdatabase = Database.create \"myDatabase\"",
      "\tDatabase.assign database env",
      "\tdatabase",
      "",
      "main.main :",
      "\tDatabase",
      "\t\t-> HttpRequest",
      "\t\t->{Exception, Storage, Remote, Random, Log} HttpResponse",
      "main.main db req =",
      "\tuse Route <|>",
      "\tRoute.run",
      "\t\t(todo \"put routes here\")",
      "\t\treq"
    ],
    "description": "Stub the spine of the app with a deploy and main function"
  },
  "crud": {
    "scope": "unison,u",
    "prefix": "#crud",
    "body": [
      "-- The data type we are operating on: $1",
      "type $1 = { id : $1.Id }",
      "type $1.Id = Id Text",
      "$1.Id.unwrap = cases Id v -> v",
      "",
      "ability $1CRUD where",
      "\tupsert : $1 ->{$1CRUD} ()",
      "\tget : $1.Id ->{$1CRUD} (Optional $1)",
      "\tdelete : $1.Id ->{$1CRUD} ()",
      "\tgetAll : {$1CRUD} (List $1)",
      "",
      "$1CRUD.run : Database -> '{g, $1CRUD} a -> {g, Remote} a",
      "$1CRUD.run db p =",
      "\t${1/(.*)/${1:/camelcase}/}s : OrderedTable ($1.Id) $1",
      "\t${1/(.*)/${1:/camelcase}/}s = OrderedTable.named db \"${1/(.*)/${1:/camelcase}/}s\" Universal.ordering",
      "",
      "\tget$1' : $1.Id ->{g, Remote} (Optional $1)",
      "\tget$1' ${1/(.*)/${1:/camelcase}/}Id = OrderedTable.tryRead ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      
      "\tgetAll' : {g, Remote} (List $1)",
      "\tgetAll' = OrderedTable.toStream ${1/(.*)/${1:/camelcase}/}s |> Stream.map at2 |> Stream.toList",
      "",
      "\tupsert$1' : $1 ->{g, Remote} ()",
      "\tupsert$1' ${1/(.*)/${1:/camelcase}/} =",
      "\t\t${1/(.*)/${1:/camelcase}/}Id = $1.id ${1/(.*)/${1:/camelcase}/}",
      "\t\tOrderedTable.write ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id ${1/(.*)/${1:/camelcase}/}",
      "",
      "\tdelete$1' : $1.Id ->{g, Remote} ()",
      "\tdelete$1' ${1/(.*)/${1:/camelcase}/}Id =",
      "\t\tOrderedTable.delete ${1/(.*)/${1:/camelcase}/}s ${1/(.*)/${1:/camelcase}/}Id",
      "",
      "\tgo : '{g, $1CRUD} a -> {g, Remote} a",
      "\tgo p = handle !p with cases",
      "\t\t{upsert ${1/(.*)/${1:/camelcase}/} -> resume} ->",
      "\t\t\tresult = upsert$1' ${1/(.*)/${1:/camelcase}/}",
      "\t\t\tgo '(resume result)",
      "\t\t{get ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = get$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{getAll -> resume} ->",
      "\t\t\tresult = getAll'",
      "\t\t\tgo '(resume result)",
      "\t\t{delete ${1/(.*)/${1:/camelcase}/}Id -> resume} ->",
      "\t\t\tresult = delete$1' ${1/(.*)/${1:/camelcase}/}Id",
      "\t\t\tgo '(resume result)",
      "\t\t{ k } -> k",
      "\tgo p"
    ],
    "description": "Stub a crud ability with a handler."
  },
  "json": {
    "scope": "unison,u",
    "prefix": "#json",
    "body": [
      "$1.fromJson : '{Decoder} $1",
      "$1.fromJson = do",
      "\tuse Decoder text",
      "\tuse object at!",
      "\tfoo = at! \"foo\" text",
      "\tbar = optionalAt! \"bar\" text",
      "\t$1 foo bar"
    ],
    "description": "Stub a decoder for a JSON object"
  },
  "crudRoutes": {
    "scope": "unison,u",
    "prefix": "#crudRoutes",
    "body": [
      "$1s.routes : '{Route, Log, Exception} ()",
      "$1s.routes =",
      "\tget${1/(.*)/${1:/pascalcase}/}s = do",
      "\t\t_ = Route.noCapture GET (Parser.s \"$1s\")",
      "\t\t$1 \"Get all $1s\"",
      "\t\tp [] [text \"render them as html\"] |> toText |> ok.html",
      "\tpost${1/(.*)/${1:/pascalcase}/}s = do",
      "\t\t_ = Route.noCapture POST (Parser.s \"$1s\")",
      "\t\tformData = getFormData()",
      "\t\t$1 \"Parse out form data, save, and return something\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tget${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route GET (Parser.s \"$1s\" / Parser.text)",
      "\t\t$1 \"Get a single $1 using the id\"",
      "\t\tp [] [text \"render it as html\"] |> toText |> ok.html",
      "\tpost${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route POST (Parser.s \"$1s\" / Parser.text)",
      "\t\tformData = getFormData()",
      "\t\t$1 \"Parse out form data, save, and return something\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tdelete${1/(.*)/${1:/pascalcase}/}= do",
      "\t\t$1Id = route DELETE (Parser.s \"$1s\" / Parser.text)",
      "\t\t$1 \"Delete a single $1 using the id\"",
      "\t\tp [] [text \"done\"] |> toText |> ok.html",
      "\tget${1/(.*)/${1:/pascalcase}/}s <|> post${1/(.*)/${1:/pascalcase}/}s <|> get${1/(.*)/${1:/pascalcase}/} <|> post${1/(.*)/${1:/pascalcase}/} <|> delete${1/(.*)/${1:/pascalcase}/}",
    ]
  }
}

